// CMakeProject1.cpp: определяет точку входа для приложения.

#include <iostream> // подключаем интерфейс для ввода/вывода
#include <fstream> // подключаем интерфейс для работы с файлами
#include <string.h> // подключаем интерфейс для работы со строками
#include <math.h> // подключаем интерфейс для матем. вычислений
#include <map> // подключаем интерфейс для ассоциативных массивов

using namespace std; // используем стандартное пространство имён

struct cmp // компаратор, меняющий порядок ключей в массиве
{
    bool operator()(const double& a, const double& b) const //метод принимает две ссылки и сравнивает их
    {
        return a > b; // возвращает булев тип, сравнивая значения
    }
};
int main() // метод, запускаемый при запуске
{
    locale::global(locale("")); // определяем локаль
    string fileName; // строковая переменная для имени файла, для чтения
    string fileExt; // строковая переменная для расширения файла, для чтения
    unsigned char byte; // переменная для байта
    size_t fileExpPosition; // переменная для позиции точки в имени файла
    map<int, int> mymap; // ассоциативный массив для байтов
    map<int, int>::iterator it; // итератор для массива mymap
    map<double, int, cmp> exitbytes; // ассоциативный массив для записи в файл
    map<double, int>::iterator itbyte; // итератор для массива exitbytes
    int exitbyte, sum = 0; // определение целых переменных
    double entropy = 0.0; // вещественная переменная для энтропии
    double key;

    cout << "Введите имя файла:" << endl;
    cin >> fileName; // пользователь вводит имя файла

    ifstream fin; //открываем поток для чтения файла
    fin.open(fileName, std::ifstream::binary); // открываем файл для чтения

    if (!fin.is_open()) // если файл невозможно открыть
        cout << "Файл не может быть открыт!\n"; // вывожу сообщение
    else // если же файл можно открыть, то приложение продолжает работу
    {
        cout << "Файл открыт для чтения" << endl; // вывожу сообщение
        while (fin.read((char*)&byte, sizeof(unsigned char))) { // читаем файл побайтово
            sum += sizeof byte; // счётчик количества байт
            exitbyte = (int)byte; // преобразовываем в int
            mymap[exitbyte]++; // байт встретился ещё один раз
        }
        fin.close(); // закрываем файл, открытый для чтения 
        cout << "Байты записаны в промежуточный массив. Файл закрыт." << endl; // вывожу сообщение

        fileExpPosition = fileName.find(".") + 1; // ищем точку, чтобы отделить расширение от имени
        fileExt = string(fileName, fileExpPosition); // получаем расширение файла, открытого для чтения

        cout << "Создаю(перезаписываю) файл: " << fileExt << "07.tab" << endl; // вывожу сообщение
        ofstream fout; //открываем поток для записи в файл
        fout.open(fileExt + "07.tab", ios_base::out | ios_base::trunc); // если файл существует, то очищаем его, если нет, то создаём
        cout << "Файл " << fileExt << "07.tab" << " открыт для записи" << endl;

        for (it = mymap.begin(); it != mymap.end(); ++it) { // проходимся в цикле по ассоциативному массиву
            key = it->second / (sum + 0.1);
            exitbytes[key] = it->first; // записываем в массив, где ключ - это байт, значение - насколько часто встречается
        }

        fout << fileName << endl; // записываем имя файла, открытого для чтения
        fout << sum << endl; // записываем в файл количество байт
        fout << endl;// добавляем пустую строку

        for (itbyte = exitbytes.begin(); itbyte != exitbytes.end(); ++itbyte) { // проходимся в цикле по ассоциативному массиву
            fout << itbyte->second << "\t" << itbyte->first << endl; // записываем Байт, затем символ табуляции, затем величину
            entropy -= itbyte->first * log10(itbyte->first) / log10(2); // рассчитываем величину энтропии по Шеннону
        }

        fout << endl; // добавляем пустую строку
        fout << entropy; // записываем последней строчкой величину энтропии Шеннона 

        cout << "Запись в файл завершена" << endl; // вывожу сообщение

        fout.close(); // закрываем файл, открытый для записи

        cout << "Работа приложения завершена успешно." << endl; // вывожу сообщение
    }
    system("pause"); // для продолжения нажмите клавишу
    return 0; // int main в случае успешного выполнения должна возвращать код 0
}